name: CD

# Security: Restrict default permissions (GitHub Security Best Practice)
# Reference: https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions
permissions:
  contents: read

on:
  # Trigger after CI workflow completes successfully
  workflow_run:
    workflows: ["CI"]
    types: [completed]
    branches: [main]

  # Manual trigger with commit SHA selection
  workflow_dispatch:
    inputs:
      commit_sha:
        description: 'Commit SHA to deploy (uses images tagged main-{sha})'
        required: true
        type: string
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      dry_run:
        description: 'Dry-run mode: validate workflow without deploying'
        required: false
        type: boolean
        default: false

env:
  # Google Artifact Registry (primary registry)
  REGISTRY_GAR: europe-west1-docker.pkg.dev
  GAR_PROJECT: extended-ascent-477308-m8
  GAR_REPO: idp-pov
  # GCP Configuration
  GCP_PROJECT_ID: extended-ascent-477308-m8
  GCP_REGION: europe-west1
  GKE_CLUSTER: baby-names-stage
  WORKLOAD_IDENTITY_PROVIDER: projects/785558430619/locations/global/workloadIdentityPools/github-2023/providers/github-2023
  # Environment URLs
  STAGING_URL: http://136.110.219.158

jobs:
  # Resolve which SHA to deploy and validate images
  resolve-sha:
    name: Resolve Deployment SHA
    runs-on: ubuntu-latest
    # Skip if workflow_run triggered by failed CI
    if: >
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
    permissions:
      contents: read
      id-token: write       # Required for WIF authentication to GAR
      attestations: read    # Required for attestation verification
    outputs:
      deploy_sha: ${{ steps.resolve.outputs.sha }}
      short_sha: ${{ steps.resolve.outputs.short_sha }}
      is_dry_run: ${{ steps.resolve.outputs.is_dry_run }}
      environment: ${{ steps.resolve.outputs.environment }}
    steps:
      - name: Authenticate to Google Cloud (WIF)
        uses: google-github-actions/auth@6fc4af4b145ae7821d527454aa9bd537d1f2dc5f  # v2.1.8
        with:
          workload_identity_provider: ${{ env.WORKLOAD_IDENTITY_PROVIDER }}
          service_account: idp-sa@${{ env.GAR_PROJECT }}.iam.gserviceaccount.com

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@e427ad8a34f8676edf47cf7d7925499adf3eb74f  # v2.1.4

      - name: Configure Docker for GAR
        run: gcloud auth configure-docker ${{ env.REGISTRY_GAR }} --quiet

      - name: Resolve deployment SHA
        id: resolve
        # Security: Use env vars for untrusted inputs (prevents script injection)
        env:
          INPUT_COMMIT_SHA: ${{ github.event.inputs.commit_sha }}
          INPUT_DRY_RUN: ${{ github.event.inputs.dry_run }}
          INPUT_ENVIRONMENT: ${{ github.event.inputs.environment }}
          EVENT_NAME: ${{ github.event_name }}
          WORKFLOW_RUN_SHA: ${{ github.event.workflow_run.head_sha }}
        run: |
          if [ "${EVENT_NAME}" == "workflow_dispatch" ]; then
            SHA="${INPUT_COMMIT_SHA}"
            IS_DRY_RUN="${INPUT_DRY_RUN}"
            ENVIRONMENT="${INPUT_ENVIRONMENT}"
          else
            # workflow_run trigger - use the SHA from the CI workflow
            SHA="${WORKFLOW_RUN_SHA}"
            IS_DRY_RUN="false"
            ENVIRONMENT="staging"
          fi

          echo "sha=${SHA}" >> $GITHUB_OUTPUT
          echo "short_sha=${SHA:0:7}" >> $GITHUB_OUTPUT
          echo "is_dry_run=${IS_DRY_RUN}" >> $GITHUB_OUTPUT
          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT

          echo "=========================================="
          echo "Deployment Configuration"
          echo "=========================================="
          echo "Commit SHA: ${SHA}"
          echo "Short SHA: ${SHA:0:7}"
          echo "Environment: ${ENVIRONMENT}"
          echo "Dry Run: ${IS_DRY_RUN}"
          echo "Trigger: ${EVENT_NAME}"
          echo "=========================================="

      - name: Validate images exist in GAR
        env:
          # Use short SHA (7 chars) to match CI's docker/metadata-action tag format
          SHORT_SHA: ${{ steps.resolve.outputs.short_sha }}
        run: |
          echo "Validating container images exist in Google Artifact Registry..."

          BACKEND_IMAGE="${{ env.REGISTRY_GAR }}/${{ env.GAR_PROJECT }}/${{ env.GAR_REPO }}/baby-names-backend:main-${SHORT_SHA}"
          FRONTEND_IMAGE="${{ env.REGISTRY_GAR }}/${{ env.GAR_PROJECT }}/${{ env.GAR_REPO }}/baby-names-frontend:main-${SHORT_SHA}"
          MIGRATION_IMAGE="${{ env.REGISTRY_GAR }}/${{ env.GAR_PROJECT }}/${{ env.GAR_REPO }}/baby-names-db-migration:main-${SHORT_SHA}"

          echo "Checking backend: ${BACKEND_IMAGE}"
          docker manifest inspect "${BACKEND_IMAGE}" > /dev/null
          echo "✅ Backend image exists"

          echo "Checking frontend: ${FRONTEND_IMAGE}"
          docker manifest inspect "${FRONTEND_IMAGE}" > /dev/null
          echo "✅ Frontend image exists"

          echo "Checking migration: ${MIGRATION_IMAGE}"
          docker manifest inspect "${MIGRATION_IMAGE}" > /dev/null
          echo "✅ Migration image exists"

          echo ""
          echo "=========================================="
          echo "All images validated in GAR!"
          echo "=========================================="

      - name: Verify attestation chain
        env:
          DEPLOY_SHA: ${{ steps.resolve.outputs.sha }}
          SHORT_SHA: ${{ steps.resolve.outputs.short_sha }}
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "=========================================="
          echo "Attestation Chain Verification"
          echo "=========================================="
          echo "Deployment SHA: ${DEPLOY_SHA}"
          echo ""

          FAILED=0

          for component in backend frontend db-migration; do
            IMAGE="${{ env.REGISTRY_GAR }}/${{ env.GAR_PROJECT }}/${{ env.GAR_REPO }}/baby-names-${component}:main-${SHORT_SHA}"
            echo "----------------------------------------"
            echo "Verifying ${component}"
            echo "----------------------------------------"

            # 1. Verify Build Provenance (SLSA)
            echo "  [1/3] Build Provenance..."
            if ! gh attestation verify "oci://${IMAGE}" \
                 --owner ${{ github.repository_owner }} \
                 --predicate-type https://slsa.dev/provenance/v1; then
              echo "  ERROR: Build Provenance missing"
              FAILED=1
            else
              echo "  ✅ Build Provenance verified"
            fi

            # 2. Verify Enhanced SBOM (with quality gate hashes)
            echo "  [2/3] Enhanced SBOM attestation..."
            SBOM_RESULT=$(gh attestation verify "oci://${IMAGE}" \
                 --owner ${{ github.repository_owner }} \
                 --predicate-type https://spdx.dev/Document \
                 --format json 2>/dev/null || echo "[]")

            if [ "${SBOM_RESULT}" == "[]" ]; then
              echo "  ERROR: SBOM attestation missing"
              FAILED=1
            else
              echo "  ✅ SBOM attestation verified"

              # Extract and display quality gate hashes from SBOM
              # The SBOM content is in the attestation predicate
              QUALITY_GATES=$(echo "${SBOM_RESULT}" | jq -r '
                .[0].verificationResult.statement.predicate.annotations[]? |
                select(.annotator == "Tool: baby-names-ci-pipeline") |
                .comment' 2>/dev/null || echo "")

              if [ -n "${QUALITY_GATES}" ]; then
                echo "  ✅ Quality gate hashes found in SBOM:"
                echo "     ${QUALITY_GATES}" | tr ';' '\n' | sed 's/^/     /'
              else
                echo "  WARNING: Quality gate hashes not found in SBOM"
                echo "           This may indicate an older build without enhanced SBOM"
              fi
            fi

            # 3. Validate git SHA from Build Provenance
            echo "  [3/3] Git SHA validation..."
            ATTESTATION_JSON=$(gh attestation verify "oci://${IMAGE}" \
                 --owner ${{ github.repository_owner }} \
                 --predicate-type https://slsa.dev/provenance/v1 \
                 --format json 2>/dev/null || echo "[]")

            ATTESTATION_SHA=$(echo "${ATTESTATION_JSON}" | \
                 jq -r '.[0].verificationResult.signature.certificate.sourceRepositoryDigest // empty')

            if [ -z "${ATTESTATION_SHA}" ]; then
              echo "  ERROR: Could not extract git SHA from attestation"
              FAILED=1
            elif [ "${ATTESTATION_SHA}" != "${DEPLOY_SHA}" ]; then
              echo "  ERROR: Git SHA mismatch!"
              echo "         Attestation: ${ATTESTATION_SHA}"
              echo "         Deployment:  ${DEPLOY_SHA}"
              FAILED=1
            else
              echo "  ✅ Git SHA validated: ${ATTESTATION_SHA:0:7}"
            fi

            echo ""
          done

          echo "=========================================="
          if [ "$FAILED" -eq 1 ]; then
            echo "ATTESTATION VERIFICATION FAILED"
            echo "Deployment blocked - supply chain integrity compromised"
            echo "=========================================="
            exit 1
          else
            echo "ALL ATTESTATIONS VERIFIED"
            echo ""
            echo "Supply chain integrity confirmed:"
            echo "  ✅ Build Provenance: CI pipeline identity"
            echo "  ✅ Enhanced SBOM: Software composition + quality gates"
            echo "  ✅ Git SHA: Deployed code = source code"
            echo "=========================================="
          fi

      - name: Dry-run summary
        if: steps.resolve.outputs.is_dry_run == 'true'
        env:
          SHORT_SHA: ${{ steps.resolve.outputs.short_sha }}
        run: |
          echo "=========================================="
          echo "DRY-RUN MODE - Deployment Plan"
          echo "=========================================="
          echo ""
          echo "Would deploy the following:"
          echo "  Commit: ${{ steps.resolve.outputs.sha }}"
          echo "  Short SHA: ${SHORT_SHA}"
          echo "  Environment: ${{ steps.resolve.outputs.environment }}"
          echo ""
          echo "Images from GAR (using short SHA tag):"
          echo "  Backend:   ${{ env.REGISTRY_GAR }}/${{ env.GAR_PROJECT }}/${{ env.GAR_REPO }}/baby-names-backend:main-${SHORT_SHA}"
          echo "  Frontend:  ${{ env.REGISTRY_GAR }}/${{ env.GAR_PROJECT }}/${{ env.GAR_REPO }}/baby-names-frontend:main-${SHORT_SHA}"
          echo "  Migration: ${{ env.REGISTRY_GAR }}/${{ env.GAR_PROJECT }}/${{ env.GAR_REPO }}/baby-names-db-migration:main-${SHORT_SHA}"
          echo ""
          echo "Validation: ✅ All images exist in GAR"
          echo ""
          echo "No actual deployment will be performed."
          echo "=========================================="

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: resolve-sha
    # Run for: workflow_run (auto) OR workflow_dispatch with staging selected
    # Skip for: dry-run mode OR production selected
    if: >
      needs.resolve-sha.outputs.is_dry_run != 'true' &&
      (github.event_name == 'workflow_run' ||
       (github.event_name == 'workflow_dispatch' && needs.resolve-sha.outputs.environment == 'staging'))
    environment:
      name: staging
      url: ${{ env.STAGING_URL }}
    permissions:
      contents: read
      id-token: write  # Required for WIF authentication
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - name: Authenticate to Google Cloud (Direct WIF)
        # NOTE: Uses direct WIF for GKE access (different SA than CI's idp-sa)
        # The images are pulled by GKE using its own SA, not this workflow SA
        uses: google-github-actions/auth@6fc4af4b145ae7821d527454aa9bd537d1f2dc5f  # v2.1.8
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}
          workload_identity_provider: ${{ env.WORKLOAD_IDENTITY_PROVIDER }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@e427ad8a34f8676edf47cf7d7925499adf3eb74f  # v2.1.4

      - name: Install gke-gcloud-auth-plugin
        run: |
          gcloud components install gke-gcloud-auth-plugin

      - name: Get GKE credentials
        run: |
          gcloud container clusters get-credentials ${{ env.GKE_CLUSTER }} \
            --region=${{ env.GCP_REGION }} \
            --project=${{ env.GCP_PROJECT_ID }}

      - name: Install Helm
        uses: azure/setup-helm@b9e51907a09c216f16ebe8536097933489208112  # v4.3.0
        with:
          version: '3.13.0'

      - name: Deploy with Helm
        working-directory: examples/baby-names/helm/baby-names
        env:
          # Use short SHA to match CI's docker/metadata-action tag format
          SHORT_SHA: ${{ needs.resolve-sha.outputs.short_sha }}
        run: |
          helm upgrade --install baby-names . \
            --namespace baby-names-stage \
            --create-namespace \
            --values values-stage.yaml \
            --set backend.image.tag=main-${SHORT_SHA} \
            --set frontend.image.tag=main-${SHORT_SHA} \
            --set migration.image.tag=main-${SHORT_SHA} \
            --wait \
            --timeout 15m

      - name: Verify deployment
        run: |
          echo "=== Verifying deployment rollout ==="

          # Wait for deployments to be ready (with timeout)
          echo "Waiting for backend deployment..."
          kubectl rollout status deployment/baby-names-backend -n baby-names-stage --timeout=5m

          echo "Waiting for frontend deployment..."
          kubectl rollout status deployment/baby-names-frontend -n baby-names-stage --timeout=5m

          # Verify all pods are running
          echo "=== Pod Status ==="
          kubectl get pods -n baby-names-stage

          # Check that no deployment pods are in error state (exclude migration job pods)
          # Migration job pods have cloud-sql-proxy sidecar that never exits
          FAILED_PODS=$(kubectl get pods -n baby-names-stage \
            --field-selector=status.phase!=Running,status.phase!=Succeeded \
            -l '!job-name' -o name 2>/dev/null | wc -l)
          if [ "$FAILED_PODS" -gt 0 ]; then
            echo "ERROR: Found $FAILED_PODS deployment pods not in Running/Succeeded state"
            kubectl get pods -n baby-names-stage --field-selector=status.phase!=Running,status.phase!=Succeeded -l '!job-name'
            exit 1
          fi

          # Check migration job completion separately (check migration container exit code)
          echo "=== Migration Job Status ==="
          MIGRATION_POD=$(kubectl get pods -n baby-names-stage -l job-name -o name 2>/dev/null | head -1)
          if [ -n "$MIGRATION_POD" ]; then
            MIGRATION_STATUS=$(kubectl get ${MIGRATION_POD} -n baby-names-stage \
              -o jsonpath='{.status.containerStatuses[?(@.name=="migration")].state.terminated.exitCode}' 2>/dev/null)
            if [ "$MIGRATION_STATUS" = "0" ]; then
              echo "Migration completed successfully (sidecar still running - expected)"
            elif [ -n "$MIGRATION_STATUS" ]; then
              echo "ERROR: Migration failed with exit code $MIGRATION_STATUS"
              kubectl logs ${MIGRATION_POD} -n baby-names-stage -c migration
              exit 1
            else
              echo "WARNING: Migration container status unknown"
            fi
          fi

          echo "=== Service Status ==="
          kubectl get services -n baby-names-stage

          echo "=== Ingress Status ==="
          kubectl get ingress -n baby-names-stage

          # Wait for ingress IP using kubectl wait (more reliable than polling loop)
          echo "Waiting for ingress IP assignment..."
          if kubectl wait --for=jsonpath='{.status.loadBalancer.ingress[0].ip}' \
               ingress/baby-names -n baby-names-stage --timeout=300s 2>/dev/null; then
            INGRESS_IP=$(kubectl get ingress baby-names -n baby-names-stage \
                         -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            echo "Ingress IP assigned: $INGRESS_IP"
          else
            echo "WARNING: Ingress IP not assigned within timeout (smoke tests may fail)"
          fi

          echo "=== Deployment verification complete ==="

      - name: Record deployment
        env:
          DEPLOY_SHA: ${{ needs.resolve-sha.outputs.deploy_sha }}
          SHORT_SHA: ${{ needs.resolve-sha.outputs.short_sha }}
        run: |
          echo "Deployment to staging completed at $(date)"
          echo "Git SHA: ${DEPLOY_SHA}"
          echo "Actor: ${{ github.actor }}"
          echo "Trigger: ${{ github.event_name }}"
          echo "Backend image: ${{ env.REGISTRY_GAR }}/${{ env.GAR_PROJECT }}/${{ env.GAR_REPO }}/baby-names-backend:main-${SHORT_SHA}"
          echo "Frontend image: ${{ env.REGISTRY_GAR }}/${{ env.GAR_PROJECT }}/${{ env.GAR_REPO }}/baby-names-frontend:main-${SHORT_SHA}"

  smoke-tests-staging:
    name: Smoke Tests (Staging)
    runs-on: ubuntu-latest
    needs: deploy-staging
    environment: staging
    permissions: {}  # No GitHub permissions needed - external HTTP only
    steps:
      # Note: No checkout/Python setup needed - smoke tests use curl only

      - name: Test frontend health endpoint
        run: |
          echo "Testing frontend health at ${{ env.STAGING_URL }}/health"
          curl --retry 10 --retry-delay 10 --retry-connrefused --fail "${{ env.STAGING_URL }}/health"

      - name: Test critical user path (full stack)
        run: |
          echo "Testing name lookup for 'Noah' via frontend"
          # Test via frontend which proxies to backend and database
          RESPONSE=$(curl --retry 5 --retry-delay 5 --retry-connrefused --fail "${{ env.STAGING_URL }}/?name=Noah")
          echo "Response received (truncated): ${RESPONSE:0:500}..."
          # Verify the response contains expected rank data
          echo "$RESPONSE" | grep -q "Rank"
          echo "✓ Name lookup returned expected rank information"

      - name: Smoke tests summary
        run: |
          echo "=========================================="
          echo "SMOKE TESTS COMPLETED SUCCESSFULLY"
          echo "=========================================="
          echo ""
          echo "All critical paths verified:"
          echo "  ✓ Frontend health endpoint responding"
          echo "  ✓ Full stack test passed (frontend -> backend -> database)"
          echo "  ✓ Name lookup functionality working"
          echo ""
          echo "Staging deployment is healthy and ready!"
          echo "=========================================="

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [resolve-sha, smoke-tests-staging]
    # Production deployment: manual only, requires staging success or skip
    # Uses !cancelled() instead of always() to prevent running after workflow cancellation
    if: >
      !cancelled() &&
      needs.resolve-sha.result == 'success' &&
      needs.resolve-sha.outputs.is_dry_run != 'true' &&
      github.event_name == 'workflow_dispatch' &&
      needs.resolve-sha.outputs.environment == 'production' &&
      (needs.smoke-tests-staging.result == 'success' || needs.smoke-tests-staging.result == 'skipped')
    environment:
      name: production
      url: https://baby-names.example.com
    permissions:
      contents: read
      id-token: write  # Required for WIF authentication
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - name: Pull images (Stubbed)
        env:
          SHORT_SHA: ${{ needs.resolve-sha.outputs.short_sha }}
        run: |
          echo "Would pull from GAR:"
          echo "  ${{ env.REGISTRY_GAR }}/${{ env.GAR_PROJECT }}/${{ env.GAR_REPO }}/baby-names-backend:main-${SHORT_SHA}"
          echo "  ${{ env.REGISTRY_GAR }}/${{ env.GAR_PROJECT }}/${{ env.GAR_REPO }}/baby-names-frontend:main-${SHORT_SHA}"

      - name: Deploy to Production Kubernetes (Stubbed)
        env:
          DEPLOY_SHA: ${{ needs.resolve-sha.outputs.deploy_sha }}
          SHORT_SHA: ${{ needs.resolve-sha.outputs.short_sha }}
        run: |
          echo "=========================================="
          echo "PRODUCTION DEPLOYMENT - CURRENTLY STUBBED"
          echo "=========================================="
          echo ""
          echo "This step would:"
          echo "  1. Configure kubectl with production cluster credentials"
          echo "  2. Apply Kubernetes manifests with production configs"
          echo "  3. Perform blue-green or canary deployment"
          echo "  4. Update image tags to: main-${SHORT_SHA}"
          echo "  5. Gradual traffic shift to new version"
          echo "  6. Monitor error rates and latency"
          echo "  7. Automatic rollback on failure"
          echo ""
          echo "Target cluster: production-k8s-cluster"
          echo "Namespace: baby-names-prod"
          echo "Backend image: ${{ env.REGISTRY_GAR }}/${{ env.GAR_PROJECT }}/${{ env.GAR_REPO }}/baby-names-backend:main-${SHORT_SHA}"
          echo "Frontend image: ${{ env.REGISTRY_GAR }}/${{ env.GAR_PROJECT }}/${{ env.GAR_REPO }}/baby-names-frontend:main-${SHORT_SHA}"
          echo ""
          echo "Production features:"
          echo "  - Multi-zone deployment for high availability"
          echo "  - Production-grade PostgreSQL with read replicas"
          echo "  - CDN for static assets"
          echo "  - WAF and DDoS protection"
          echo "  - Comprehensive monitoring and alerting"
          echo ""
          echo "=========================================="

      - name: Record production deployment
        env:
          DEPLOY_SHA: ${{ needs.resolve-sha.outputs.deploy_sha }}
          SHORT_SHA: ${{ needs.resolve-sha.outputs.short_sha }}
        run: |
          echo "Production deployment completed at $(date)"
          echo "Git SHA: ${DEPLOY_SHA}"
          echo "Image tag: main-${SHORT_SHA}"
          echo "Actor: ${{ github.actor }}"
          echo "Trigger: ${{ github.event_name }}"
          echo "Deployment requires manual approval via GitHub Environments"

  smoke-tests-production:
    name: Smoke Tests (Production)
    runs-on: ubuntu-latest
    needs: deploy-production
    environment: production
    permissions: {}  # No GitHub permissions needed - external HTTP only
    steps:
      # Note: No checkout/Python setup needed - smoke tests use curl only (stubbed for now)

      - name: Run smoke tests (Stubbed)
        env:
          BACKEND_URL: https://api.baby-names.example.com
          FRONTEND_URL: https://baby-names.example.com
        run: |
          echo "=========================================="
          echo "PRODUCTION SMOKE TESTS - CURRENTLY STUBBED"
          echo "=========================================="
          echo ""
          echo "This step would run:"
          echo "  pytest tests/smoke/ -v"
          echo ""
          echo "Against production endpoints:"
          echo "  Backend: $BACKEND_URL"
          echo "  Frontend: $FRONTEND_URL"
          echo ""
          echo "Tests would verify:"
          echo "  ✓ Services are responding"
          echo "  ✓ Health endpoints return 200"
          echo "  ✓ Database connectivity"
          echo "  ✓ Critical user path (search for name)"
          echo "  ✓ Top names are present in database"
          echo "  ✓ SSL certificates valid"
          echo "  ✓ Response times within SLO"
          echo ""
          echo "All production smoke tests passed (simulated)"
          echo "=========================================="

      - name: Notify deployment success
        run: |
          echo "Production deployment verified successfully"
          echo "Application is live at https://baby-names.example.com"
