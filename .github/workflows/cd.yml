name: CD

# Security: Restrict default permissions (GitHub Security Best Practice)
# Reference: https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions
permissions:
  contents: read

on:
  # Trigger after CI workflow completes successfully
  workflow_run:
    workflows: ["CI"]
    types: [completed]
    branches: [main]

  # Manual trigger with commit SHA selection
  workflow_dispatch:
    inputs:
      commit_sha:
        description: 'Commit SHA to deploy (uses images tagged main-{sha})'
        required: true
        type: string
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      dry_run:
        description: 'Dry-run mode: validate workflow without deploying'
        required: false
        type: boolean
        default: false

env:
  # Google Artifact Registry (primary registry)
  REGISTRY_GAR: europe-west1-docker.pkg.dev
  GAR_PROJECT: extended-ascent-477308-m8
  GAR_REPO: idp-pov
  # GCP Configuration
  GCP_PROJECT_ID: extended-ascent-477308-m8
  GCP_REGION: europe-west1
  GKE_CLUSTER: hellow-world-manual
  WORKLOAD_IDENTITY_PROVIDER: projects/785558430619/locations/global/workloadIdentityPools/github-2023/providers/github-2023
  # Environment URLs
  STAGING_URL: http://gke-df4e635bf6a042d9a06ccadd5f88beab6860-254825841253.europe-west1.gke.goog

jobs:
  # Resolve which SHA to deploy and validate images
  resolve-sha:
    name: Resolve Deployment SHA
    runs-on: ubuntu-latest
    # Skip if workflow_run triggered by failed CI
    if: >
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
    permissions:
      contents: read
      id-token: write       # Required for WIF authentication to GAR
      attestations: read    # Required for attestation verification
    outputs:
      deploy_sha: ${{ steps.resolve.outputs.sha }}
      short_sha: ${{ steps.resolve.outputs.short_sha }}
      is_dry_run: ${{ steps.resolve.outputs.is_dry_run }}
      environment: ${{ steps.resolve.outputs.environment }}
    steps:
      - name: Authenticate to Google Cloud (WIF)
        uses: google-github-actions/auth@6fc4af4b145ae7821d527454aa9bd537d1f2dc5f  # v2.1.8
        with:
          workload_identity_provider: ${{ env.WORKLOAD_IDENTITY_PROVIDER }}
          service_account: idp-sa@${{ env.GAR_PROJECT }}.iam.gserviceaccount.com

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@e427ad8a34f8676edf47cf7d7925499adf3eb74f  # v2.1.4

      - name: Configure Docker for GAR
        run: gcloud auth configure-docker ${{ env.REGISTRY_GAR }} --quiet

      - name: Resolve deployment SHA
        id: resolve
        # Security: Use env vars for untrusted inputs (prevents script injection)
        env:
          INPUT_COMMIT_SHA: ${{ github.event.inputs.commit_sha }}
          INPUT_DRY_RUN: ${{ github.event.inputs.dry_run }}
          INPUT_ENVIRONMENT: ${{ github.event.inputs.environment }}
          EVENT_NAME: ${{ github.event_name }}
          WORKFLOW_RUN_SHA: ${{ github.event.workflow_run.head_sha }}
        run: |
          if [ "${EVENT_NAME}" == "workflow_dispatch" ]; then
            SHA="${INPUT_COMMIT_SHA}"
            IS_DRY_RUN="${INPUT_DRY_RUN}"
            ENVIRONMENT="${INPUT_ENVIRONMENT}"
          else
            # workflow_run trigger - use the SHA from the CI workflow
            SHA="${WORKFLOW_RUN_SHA}"
            IS_DRY_RUN="false"
            ENVIRONMENT="staging"
          fi

          echo "sha=${SHA}" >> $GITHUB_OUTPUT
          echo "short_sha=${SHA:0:7}" >> $GITHUB_OUTPUT
          echo "is_dry_run=${IS_DRY_RUN}" >> $GITHUB_OUTPUT
          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT

          echo "=========================================="
          echo "Deployment Configuration"
          echo "=========================================="
          echo "Commit SHA: ${SHA}"
          echo "Short SHA: ${SHA:0:7}"
          echo "Environment: ${ENVIRONMENT}"
          echo "Dry Run: ${IS_DRY_RUN}"
          echo "Trigger: ${EVENT_NAME}"
          echo "=========================================="

      - name: Validate images exist in GAR
        env:
          # Use short SHA (7 chars) to match CI's docker/metadata-action tag format
          SHORT_SHA: ${{ steps.resolve.outputs.short_sha }}
        run: |
          echo "Validating container images exist in Google Artifact Registry..."

          BACKEND_IMAGE="${{ env.REGISTRY_GAR }}/${{ env.GAR_PROJECT }}/${{ env.GAR_REPO }}/baby-names-backend:main-${SHORT_SHA}"
          FRONTEND_IMAGE="${{ env.REGISTRY_GAR }}/${{ env.GAR_PROJECT }}/${{ env.GAR_REPO }}/baby-names-frontend:main-${SHORT_SHA}"
          MIGRATION_IMAGE="${{ env.REGISTRY_GAR }}/${{ env.GAR_PROJECT }}/${{ env.GAR_REPO }}/baby-names-db-migration:main-${SHORT_SHA}"

          echo "Checking backend: ${BACKEND_IMAGE}"
          docker manifest inspect "${BACKEND_IMAGE}" > /dev/null
          echo "✅ Backend image exists"

          echo "Checking frontend: ${FRONTEND_IMAGE}"
          docker manifest inspect "${FRONTEND_IMAGE}" > /dev/null
          echo "✅ Frontend image exists"

          echo "Checking migration: ${MIGRATION_IMAGE}"
          docker manifest inspect "${MIGRATION_IMAGE}" > /dev/null
          echo "✅ Migration image exists"

          echo ""
          echo "=========================================="
          echo "All images validated in GAR!"
          echo "=========================================="

      - name: Verify build attestations (non-blocking)
        # TODO: Make this blocking once CI is fixed to use manifest digest for attestations
        # Current issue: CI attests using config digest (docker inspect --format='{{.Id}}')
        # but verification looks up by manifest digest from registry. These don't match.
        # Fix: Update CI to push first, then use `crane digest` or similar for attestation.
        continue-on-error: true
        env:
          SHORT_SHA: ${{ steps.resolve.outputs.short_sha }}
          GH_TOKEN: ${{ github.token }}
        run: |
          echo "Verifying build attestations for all images..."
          echo "NOTE: This step is currently non-blocking (warning only)."
          echo "Attestation verification will be enforced after CI fix."
          echo ""
          FAILED=0

          for component in backend frontend db-migration; do
            IMAGE="${{ env.REGISTRY_GAR }}/${{ env.GAR_PROJECT }}/${{ env.GAR_REPO }}/baby-names-${component}:main-${SHORT_SHA}"
            echo "Verifying ${component} attestation..."
            if ! gh attestation verify "oci://${IMAGE}" \
                 --owner ${{ github.repository_owner }}; then
              echo "⚠️ WARNING: Attestation verification failed for ${component}"
              FAILED=1
            else
              echo "✅ ${component} attestation verified"
            fi
            echo ""
          done

          if [ "$FAILED" -eq 1 ]; then
            echo "=========================================="
            echo "⚠️ WARNING: Attestation verification failed!"
            echo "Proceeding with deployment (non-blocking mode)."
            echo "TODO: Fix CI attestation digest and enable blocking."
            echo "=========================================="
          else
            echo "=========================================="
            echo "All attestations verified successfully!"
            echo "Images confirmed from trusted CI pipeline."
            echo "=========================================="
          fi

      - name: Dry-run summary
        if: steps.resolve.outputs.is_dry_run == 'true'
        env:
          SHORT_SHA: ${{ steps.resolve.outputs.short_sha }}
        run: |
          echo "=========================================="
          echo "DRY-RUN MODE - Deployment Plan"
          echo "=========================================="
          echo ""
          echo "Would deploy the following:"
          echo "  Commit: ${{ steps.resolve.outputs.sha }}"
          echo "  Short SHA: ${SHORT_SHA}"
          echo "  Environment: ${{ steps.resolve.outputs.environment }}"
          echo ""
          echo "Images from GAR (using short SHA tag):"
          echo "  Backend:   ${{ env.REGISTRY_GAR }}/${{ env.GAR_PROJECT }}/${{ env.GAR_REPO }}/baby-names-backend:main-${SHORT_SHA}"
          echo "  Frontend:  ${{ env.REGISTRY_GAR }}/${{ env.GAR_PROJECT }}/${{ env.GAR_REPO }}/baby-names-frontend:main-${SHORT_SHA}"
          echo "  Migration: ${{ env.REGISTRY_GAR }}/${{ env.GAR_PROJECT }}/${{ env.GAR_REPO }}/baby-names-db-migration:main-${SHORT_SHA}"
          echo ""
          echo "Validation: ✅ All images exist in GAR"
          echo ""
          echo "No actual deployment will be performed."
          echo "=========================================="

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: resolve-sha
    # Run for: workflow_run (auto) OR workflow_dispatch with staging selected
    # Skip for: dry-run mode OR production selected
    if: >
      needs.resolve-sha.outputs.is_dry_run != 'true' &&
      (github.event_name == 'workflow_run' ||
       (github.event_name == 'workflow_dispatch' && needs.resolve-sha.outputs.environment == 'staging'))
    environment:
      name: staging
      url: ${{ env.STAGING_URL }}
    permissions:
      contents: read
      id-token: write  # Required for WIF authentication
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - name: Authenticate to Google Cloud (Direct WIF)
        # NOTE: Uses direct WIF for GKE access (different SA than CI's idp-sa)
        # The images are pulled by GKE using its own SA, not this workflow SA
        uses: google-github-actions/auth@6fc4af4b145ae7821d527454aa9bd537d1f2dc5f  # v2.1.8
        with:
          project_id: ${{ env.GCP_PROJECT_ID }}
          workload_identity_provider: ${{ env.WORKLOAD_IDENTITY_PROVIDER }}

      - name: Set up Cloud SDK
        uses: google-github-actions/setup-gcloud@e427ad8a34f8676edf47cf7d7925499adf3eb74f  # v2.1.4

      - name: Install gke-gcloud-auth-plugin
        run: |
          gcloud components install gke-gcloud-auth-plugin

      - name: Get GKE credentials
        run: |
          gcloud container clusters get-credentials ${{ env.GKE_CLUSTER }} \
            --region=${{ env.GCP_REGION }} \
            --project=${{ env.GCP_PROJECT_ID }}

      - name: Install Helm
        uses: azure/setup-helm@b9e51907a09c216f16ebe8536097933489208112  # v4.3.0
        with:
          version: '3.13.0'

      - name: Deploy with Helm
        working-directory: examples/baby-names/helm/baby-names
        env:
          # Use short SHA to match CI's docker/metadata-action tag format
          SHORT_SHA: ${{ needs.resolve-sha.outputs.short_sha }}
        run: |
          helm upgrade --install baby-names . \
            --namespace baby-names-staging \
            --create-namespace \
            --values values-staging.yaml \
            --set backend.image.tag=main-${SHORT_SHA} \
            --set frontend.image.tag=main-${SHORT_SHA} \
            --set migration.image.tag=main-${SHORT_SHA} \
            --wait \
            --timeout 15m

      - name: Verify deployment
        run: |
          echo "=== Verifying deployment rollout ==="

          # Wait for deployments to be ready (with timeout)
          echo "Waiting for backend deployment..."
          kubectl rollout status deployment/baby-names-backend -n baby-names-staging --timeout=5m

          echo "Waiting for frontend deployment..."
          kubectl rollout status deployment/baby-names-frontend -n baby-names-staging --timeout=5m

          # Verify all pods are running
          echo "=== Pod Status ==="
          kubectl get pods -n baby-names-staging

          # Check that no pods are in error state
          FAILED_PODS=$(kubectl get pods -n baby-names-staging --field-selector=status.phase!=Running,status.phase!=Succeeded -o name 2>/dev/null | wc -l)
          if [ "$FAILED_PODS" -gt 0 ]; then
            echo "ERROR: Found $FAILED_PODS pods not in Running/Succeeded state"
            kubectl get pods -n baby-names-staging --field-selector=status.phase!=Running,status.phase!=Succeeded
            exit 1
          fi

          echo "=== Service Status ==="
          kubectl get services -n baby-names-staging

          echo "=== Ingress Status ==="
          kubectl get ingress -n baby-names-staging

          # Wait for ingress IP using kubectl wait (more reliable than polling loop)
          echo "Waiting for ingress IP assignment..."
          if kubectl wait --for=jsonpath='{.status.loadBalancer.ingress[0].ip}' \
               ingress/baby-names -n baby-names-staging --timeout=300s 2>/dev/null; then
            INGRESS_IP=$(kubectl get ingress baby-names -n baby-names-staging \
                         -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            echo "Ingress IP assigned: $INGRESS_IP"
          else
            echo "WARNING: Ingress IP not assigned within timeout (smoke tests may fail)"
          fi

          echo "=== Deployment verification complete ==="

      - name: Record deployment
        env:
          DEPLOY_SHA: ${{ needs.resolve-sha.outputs.deploy_sha }}
          SHORT_SHA: ${{ needs.resolve-sha.outputs.short_sha }}
        run: |
          echo "Deployment to staging completed at $(date)"
          echo "Git SHA: ${DEPLOY_SHA}"
          echo "Actor: ${{ github.actor }}"
          echo "Trigger: ${{ github.event_name }}"
          echo "Backend image: ${{ env.REGISTRY_GAR }}/${{ env.GAR_PROJECT }}/${{ env.GAR_REPO }}/baby-names-backend:main-${SHORT_SHA}"
          echo "Frontend image: ${{ env.REGISTRY_GAR }}/${{ env.GAR_PROJECT }}/${{ env.GAR_REPO }}/baby-names-frontend:main-${SHORT_SHA}"

  smoke-tests-staging:
    name: Smoke Tests (Staging)
    runs-on: ubuntu-latest
    needs: deploy-staging
    environment: staging
    permissions: {}  # No GitHub permissions needed - external HTTP only
    steps:
      # Note: No checkout/Python setup needed - smoke tests use curl only

      - name: Test frontend health endpoint
        run: |
          echo "Testing frontend health at ${{ env.STAGING_URL }}/health"
          curl --retry 10 --retry-delay 10 --retry-connrefused --fail "${{ env.STAGING_URL }}/health"

      - name: Test backend health endpoint (via frontend proxy)
        run: |
          echo "Testing backend health via ${{ env.STAGING_URL }}/api/health"
          curl --retry 10 --retry-delay 10 --retry-connrefused --fail "${{ env.STAGING_URL }}/api/health"

      - name: Test critical user path
        run: |
          echo "Testing name lookup for 'Noah'"
          RESPONSE=$(curl --fail "${{ env.STAGING_URL }}/api/names/Noah")
          echo "Response: $RESPONSE"
          echo "$RESPONSE" | grep -q "rank"

      - name: Smoke tests summary
        run: |
          echo "=========================================="
          echo "SMOKE TESTS COMPLETED SUCCESSFULLY"
          echo "=========================================="
          echo ""
          echo "All critical paths verified:"
          echo "  ✓ Frontend health endpoint responding"
          echo "  ✓ Backend health endpoint responding"
          echo "  ✓ Database connectivity verified"
          echo "  ✓ Name lookup functionality working"
          echo ""
          echo "Staging deployment is healthy and ready!"
          echo "=========================================="

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [resolve-sha, smoke-tests-staging]
    # Production deployment: manual only, requires staging success or skip
    # Uses !cancelled() instead of always() to prevent running after workflow cancellation
    if: >
      !cancelled() &&
      needs.resolve-sha.result == 'success' &&
      needs.resolve-sha.outputs.is_dry_run != 'true' &&
      github.event_name == 'workflow_dispatch' &&
      needs.resolve-sha.outputs.environment == 'production' &&
      (needs.smoke-tests-staging.result == 'success' || needs.smoke-tests-staging.result == 'skipped')
    environment:
      name: production
      url: https://baby-names.example.com
    permissions:
      contents: read
      id-token: write  # Required for WIF authentication
    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683  # v4.2.2

      - name: Pull images (Stubbed)
        env:
          SHORT_SHA: ${{ needs.resolve-sha.outputs.short_sha }}
        run: |
          echo "Would pull from GAR:"
          echo "  ${{ env.REGISTRY_GAR }}/${{ env.GAR_PROJECT }}/${{ env.GAR_REPO }}/baby-names-backend:main-${SHORT_SHA}"
          echo "  ${{ env.REGISTRY_GAR }}/${{ env.GAR_PROJECT }}/${{ env.GAR_REPO }}/baby-names-frontend:main-${SHORT_SHA}"

      - name: Deploy to Production Kubernetes (Stubbed)
        env:
          DEPLOY_SHA: ${{ needs.resolve-sha.outputs.deploy_sha }}
          SHORT_SHA: ${{ needs.resolve-sha.outputs.short_sha }}
        run: |
          echo "=========================================="
          echo "PRODUCTION DEPLOYMENT - CURRENTLY STUBBED"
          echo "=========================================="
          echo ""
          echo "This step would:"
          echo "  1. Configure kubectl with production cluster credentials"
          echo "  2. Apply Kubernetes manifests with production configs"
          echo "  3. Perform blue-green or canary deployment"
          echo "  4. Update image tags to: main-${SHORT_SHA}"
          echo "  5. Gradual traffic shift to new version"
          echo "  6. Monitor error rates and latency"
          echo "  7. Automatic rollback on failure"
          echo ""
          echo "Target cluster: production-k8s-cluster"
          echo "Namespace: baby-names-prod"
          echo "Backend image: ${{ env.REGISTRY_GAR }}/${{ env.GAR_PROJECT }}/${{ env.GAR_REPO }}/baby-names-backend:main-${SHORT_SHA}"
          echo "Frontend image: ${{ env.REGISTRY_GAR }}/${{ env.GAR_PROJECT }}/${{ env.GAR_REPO }}/baby-names-frontend:main-${SHORT_SHA}"
          echo ""
          echo "Production features:"
          echo "  - Multi-zone deployment for high availability"
          echo "  - Production-grade PostgreSQL with read replicas"
          echo "  - CDN for static assets"
          echo "  - WAF and DDoS protection"
          echo "  - Comprehensive monitoring and alerting"
          echo ""
          echo "=========================================="

      - name: Record production deployment
        env:
          DEPLOY_SHA: ${{ needs.resolve-sha.outputs.deploy_sha }}
          SHORT_SHA: ${{ needs.resolve-sha.outputs.short_sha }}
        run: |
          echo "Production deployment completed at $(date)"
          echo "Git SHA: ${DEPLOY_SHA}"
          echo "Image tag: main-${SHORT_SHA}"
          echo "Actor: ${{ github.actor }}"
          echo "Trigger: ${{ github.event_name }}"
          echo "Deployment requires manual approval via GitHub Environments"

  smoke-tests-production:
    name: Smoke Tests (Production)
    runs-on: ubuntu-latest
    needs: deploy-production
    environment: production
    permissions: {}  # No GitHub permissions needed - external HTTP only
    steps:
      # Note: No checkout/Python setup needed - smoke tests use curl only (stubbed for now)

      - name: Run smoke tests (Stubbed)
        env:
          BACKEND_URL: https://api.baby-names.example.com
          FRONTEND_URL: https://baby-names.example.com
        run: |
          echo "=========================================="
          echo "PRODUCTION SMOKE TESTS - CURRENTLY STUBBED"
          echo "=========================================="
          echo ""
          echo "This step would run:"
          echo "  pytest tests/smoke/ -v"
          echo ""
          echo "Against production endpoints:"
          echo "  Backend: $BACKEND_URL"
          echo "  Frontend: $FRONTEND_URL"
          echo ""
          echo "Tests would verify:"
          echo "  ✓ Services are responding"
          echo "  ✓ Health endpoints return 200"
          echo "  ✓ Database connectivity"
          echo "  ✓ Critical user path (search for name)"
          echo "  ✓ Top names are present in database"
          echo "  ✓ SSL certificates valid"
          echo "  ✓ Response times within SLO"
          echo ""
          echo "All production smoke tests passed (simulated)"
          echo "=========================================="

      - name: Notify deployment success
        run: |
          echo "Production deployment verified successfully"
          echo "Application is live at https://baby-names.example.com"
